Задача для Cursor: “Добавить сценарий распила в CSV”

Цель:
По входному CSV (результат оптимизации раскроя) автоматически сформировать производственный сценарий:

Set List — список установок упора (длина) и сколько резов на этой установке.

Per-Board сценарий — упорядоченная последовательность операций для каждой доски (или ссылка на “программу”), чтобы можно было печатать/контролировать.

Входные данные

CSV вида (как у нас):

Board (int) — номер доски

BoardW (int) — ширина (например 195)

Kerf (int) — пропил (например 4)

Cut1..Cut60 (float/int/строка, может быть пусто) — длины отрезков по порядку

Remainder (int) — остаток на доске (мм)

Допущение: длина исходной доски вычисляется как:
BoardLen = sum(Cuts) + Kerf*(nCuts-1) + Remainder
(если kerf применим между резами; если у вас иначе — вынести в настройку)

Что нужно добавить в CSV (выход)

Сгенерировать новый CSV или расширить существующий дополнительными колонками:

Колонки сценария на уровне доски

ScenarioId (string) — идентификатор программы/паттерна (например W195_P03)

ScenarioOps (string) — последовательность установок упора и количества резов на этой доске
Формат, например: 3000x2 или 3090x1|590x4|549x1

ScenarioSetups (int) — число перестановок (кол-во уникальных длин в ScenarioOps)

ScenarioGroup (string) — режим/группа (например FAST)

Отдельный файл (рекомендовано) для цеха

Создать второй CSV set_list.csv со столбцами:

BoardW

ScenarioId

StopLength (int) — длина упора

CutsCount (int) — сколько резов на этой длине в рамках сценария

BoardsCount (int) — сколько досок участвует в сценарии

OpOrder (int) — порядок выполнения установок (опционально)

Плюс итоговая агрегация по ширине:
set_list_summary.csv:

BoardW

StopLength

TotalCuts

Логика “сценария распила” (FastProduction)
1) Нормализация

Прочитать Cut1..Cut60

Отбросить пустые

Привести к int (round)

(опционально) квантовать длины: step_mm (настройка, дефолт 1 или 0)

2) Выделение “паттерна” доски

Паттерн = мультисет длин в порядке реза или без порядка (настройка):

Режим ORDERED: паттерн = список длин как есть: [1712,4291,96]

Режим UNORDERED: паттерн = отсортированный список: [96,1712,4291]

Рекомендация для fast: использовать UNORDERED, а потом строить операции как “группы одинаковых длин”.

3) Формирование операций для доски

Из списка длин (лучше отсортированного по убыванию или по выбранной стратегии) сделать “runs”:

Сгруппировать одинаковые длины: 3000x2, 590x4, 96x1

Итоговая строка: 3090x1|590x4|549x1

Стратегия сортировки внутри доски:

DESC (по убыванию) — часто удобнее и стабильнее

или AS_IS (как в исходном раскрое)

4) Группировка досок в сценарии

Сценарий = группа досок с одинаковым набором операций (ScenarioOps) и одинаковой шириной BoardW.

ScenarioId формировать как:
W{BoardW}_S{index:02d}

5) Генерация Set List

Для каждого сценария:

распарсить ScenarioOps

суммировать резы по каждой длине упора

посчитать BoardsCount

Плюс общий summary по ширине:

суммировать по StopLength

Настройки (через аргументы CLI или конфиг)

--pattern_mode {ordered,unordered} (default: unordered)

--op_sort {desc,asc,asis} (default: desc)

--round_step_mm (default: 1; 0 = отключить)

--min_group_size (default: 2) — если сценарий встречается 1 раз, можно пометить как ScenarioGroup=TAIL

--output_dir

Требования к качеству

Для каждой строки входного CSV есть заполненные:

ScenarioId, ScenarioOps, ScenarioSetups

В set_list.csv:

операции внутри сценария отсортированы по OpOrder (если задано)

CutsCount корректно суммируется

Все числа — целые мм.

Код устойчив к пустым Cut*, строковым значениям, NaN.

Покрыть тестами минимум:

доска 3000,3000 → 3000x2

доска 3090,590,590,590,590,549 → 3090x1|590x4|549x1

доска с единичным паттерном → попадает в TAIL

Пример ожидаемого результата (для одного BoardW=195)

В исходном CSV есть строка:
Cut1=3000 Cut2=3000 Remainder=16 Kerf=4

В выходном:

ScenarioOps = "3000x2"

ScenarioSetups = 1

И set_list_summary.csv покажет:

StopLength=3000 TotalCuts=112 (если 56 досок)